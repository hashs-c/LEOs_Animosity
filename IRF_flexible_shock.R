






## Bootstrap

.bootnew <-function (x, n.ahead, runs, ortho, cumulative, impulse, response, 
                  ci, seed,shock, y.names) 
{
  if (!(is.null(seed))) 
    set.seed(abs(as.integer(seed)))
  if (class(x) == "varest") {
    VAR <- eval.parent(x)
  }
  else if (class(x) == "svarest") {
    VAR <- eval.parent(x$var)
  }
  else {
    stop("Bootstrap not implemented for this class.\n")
  }
  p <- VAR$p
  K <- VAR$K
  obs   <- VAR$obs
  total <- VAR$totobs
  type  <- VAR$type
  B     <- Bcoef(VAR)
  BOOT <- vector("list", runs)
  ysampled <- matrix(0, nrow = total, ncol = K)
  colnames(ysampled) <- colnames(VAR$y)
  Zdet <- NULL
  if (ncol(VAR$datamat) > (K * (p + 1))) {
    Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
  }
  resorig <- scale(resid(VAR), scale = FALSE)
  B <- Bcoef(VAR)
  for (i in 1:runs) {
    booted <- sample(c(1:obs), replace = TRUE)
    resid <- resorig[booted, ]
    lasty <- c(t(VAR$y[p:1, ]))
    ysampled[c(1:p), ] <- VAR$y[c(1:p), ]
    for (j in 1:obs) {
      lasty <- lasty[1:(K * p)]
      Z <- c(lasty, Zdet[j, ])
      ysampled[j + p, ] <- B %*% Z + resid[j, ]
      lasty <- c(ysampled[j + p, ], lasty)
    }
    varboot <- update(VAR, y = ysampled)
    if (class(x) == "svarest") {
      varboot <- update(x, x = varboot)
    }
    BOOT[[i]] <- psGIRF(x = varboot, n.ahead = n.ahead, ortho = ortho, 
                      cumulative = T, impulse = impulse, response = response,shock=shock, 
                      y.names = y.names)
  }
  lower <- ci/2
  upper <- 1 - ci/2
  mat.l <- matrix(NA, nrow = n.ahead, ncol = length(response))
  mat.u <- matrix(NA, nrow = n.ahead, ncol = length(response))
  Lower <- list()
  Upper <- list()
  idx1 <- length(impulse)
  idx2 <- length(response)
  idx3 <- n.ahead 
  temp <- rep(NA, runs)
  for (j in 1:idx1) {
    for (m in 1:idx2) {
      for (l in 1:idx3) {
        for (i in 1:runs) {
          if (idx2 > 1) {
            temp[i] <- BOOT[[i]][[j]][l, m]
          }
          else {
            temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
          }
        }
        mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
        mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
      }
    }
    colnames(mat.l) <- response
    colnames(mat.u) <- response
    Lower[[j]] <- mat.l
    Upper[[j]] <- mat.u
  }
  names(Lower) <- impulse
  names(Upper) <- impulse
  result <- list(Lower = Lower, Upper = Upper)
  return(result)
}

## final IRF

irf_corrected <- function (x, impulse = NULL, response = NULL, n.ahead = 10, ortho = TRUE, 
                           cumulative = FALSE, boot = TRUE, ci = 0.95, runs = 100, seed = NULL,
                           ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  y.names <- colnames(x$y)
  if (is.null(impulse)) {
    impulse <- y.names
  }
  else {
    impulse <- as.vector(as.character(impulse))
    if (any(!(impulse %in% y.names))) {
      stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
    }
    impulse <- subset(y.names, subset = y.names %in% impulse)
  }
  if (is.null(response)) {
    response <- y.names
  }
  else {
    response <- as.vector(as.character(response))
    if (any(!(response %in% y.names))) {
      stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
    }
    response <- subset(y.names, subset = y.names %in% response)
  }
  irs <- psGIRF(x = x, impulse = impulse, response = response, 
               n.ahead = n.ahead, ortho = ortho, 
              cumulative = cumulative)

  Lower <- NULL
  Upper <- NULL
  if (boot) {
    ci <- as.numeric(ci)
    if ((ci <= 0) | (ci >= 1)) {
      stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
    }
    ci <- 1 - ci
    BOOT <- .bootnew(x = x, n.ahead = n.ahead, runs = runs, 
                  ortho = ortho, cumulative = cumulative, impulse = impulse, 
                  response = response, ci = ci, seed = seed, shock=shock,y.names = y.names)
    Lower <- BOOT$Lower
    Upper <- BOOT$Upper
  }
  
  result <- list(irf = irs, Lower = Lower, Upper = Upper, response = response, 
                 impulse = impulse, ortho = ortho, cumulative = cumulative, 
                 runs = runs, ci = ci, boot = boot,model = class(x))
  #class(result) <- "varirf"
  return(result)
}


## LO to Probs

LOtoProb <- function(x){
  odds <- exp(x)
  prob <- odds/(1+odds)
  return(prob)
}


## Relative Risk
RR <- function(x,or) {return(or/(1-x+(x*or)))}

DeltaLOtoDeltaProb<-function(x,impulse,response,logodds=F){
  
  BaseRate      <- mean(LOtoProb(response))

  odds_ratio     <- exp(x)
  relative_risk  <- sapply(1:length(odds_ratio),FUN= function(k) RR(BaseRate[k],odds_ratio[k])) 
  prob_change    <- 100*(abs(relative_risk*BaseRate)-abs(BaseRate))
  
  if(!logodds){
  return(prob_change)}
  if(logodds){
    return(x)
  }
}


DeltaLOtoDeltaProb_value<-function(x,BaseRate){
  
  
  odds_ratio     <- exp(x)
  relative_risk  <- sapply(1:length(odds_ratio),FUN= function(k) RR(BaseRate[k],odds_ratio[k])) 
  prob_change    <- 100*(abs(relative_risk*BaseRate)-abs(BaseRate))

    return(prob_change)

}

psGIRF <- function(x, n.ahead = 20, cumulative = TRUE, orthog = FALSE,...){
  
  y.names <- colnames(x$y)
  impulse <- y.names
  response <- y.names
  
  # Ensure n.ahead is an integer
  n.ahead <- abs(as.integer(n.ahead))
  
  # Create arrays to hold calculations     
  # [1:nlags, 1:nvariables, shocked variable ] 
  
  IRF_o  = array(data = 0, dim = c(n.ahead,x$K,x$K),
                 dimnames = list(NULL,y.names,y.names))       
  IRF_g  = array(data = 0, dim = c(n.ahead,x$K,x$K),
                 dimnames = list(NULL,y.names,y.names))
  IRF_g1 = array(data = 0, dim = c(n.ahead,x$K,x$K))
  
  # Estimation of orthogonalised and generalised IRFs
  SpecMA <- Phi(x, n.ahead)
  params <- ncol(x$datamat[, -c(1:x$K)])
  sigma.u <- crossprod(resid(x))/(x$obs - params)
  P <- t(chol(sigma.u))
  sig_jj <- diag(sigma.u)
  
  for (jj in 1:x$K){
    indx_      <- matrix(0,x$K,1)
    indx_[jj,1] <- 1
    
    for (kk in 1:n.ahead){  #kk counts the lag
      
      IRF_o[kk, ,jj] <- SpecMA[, ,kk]%*%P%*%indx_  # Peseran-Shin eqn 7 (OIRF)
      
      IRF_g1[kk, ,jj] <- SpecMA[, ,kk]%*%sigma.u%*%indx_
      IRF_g[kk, ,jj] <- 2*sig_jj[jj]^(-0.5)*IRF_g1[kk, ,jj]  # Peseran-Shin eqn 10 (GIRF)
      
    }
  }
  
  if(orthog==TRUE){
    irf <- IRF_o
  } else if(orthog==FALSE) {
    irf <- IRF_g
  } else {
    stop("\nError! Orthogonalised or generalised IRF?\n")
  }
  
  idx <- length(impulse)
  irs <- list()
  for (ii in 1:idx) {
    irs[[ii]] <- matrix(irf[1:(n.ahead), response, impulse[ii]], nrow = n.ahead)
    colnames(irs[[ii]]) <- response
    if (cumulative) {
      if (length(response) > 1) 
        irs[[ii]] <- apply(irs[[ii]], 2, cumsum)
      if (length(response) == 1) {
        tmp <- matrix(cumsum(irs[[ii]]))
        colnames(tmp) <- response
        irs[[ii]] <- tmp
      }
    }
  }
  names(irs) <- impulse
  result <- irs
  return(result)
  
}


